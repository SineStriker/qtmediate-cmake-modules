#include <iostream>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <regex>

#include <syscmdline/parser.h>
#include <syscmdline/system.h>

#include "sha-256.h"
#include "utils.h"

namespace SCL = SysCmdLine;

namespace fs = std::filesystem;

using SCL::u8printf;

// ---------------------------------------- Definitions ----------------------------------------

#ifdef _WIN32
#  define OS_EXECUTABLE "Windows PE"
#elif defined(__APPLE__)
#  define OS_EXECUTABLE "Mach-O"
#else
#  define OS_EXECUTABLE "ELF"
#endif

#ifdef _WIN32
using TChar = wchar_t;
using TString = std::wstring;
#else
using TChar = char;
using TString = std::string;
#endif

using TStringList = std::vector<TString>;

#ifdef _WIN32
#  define _TSTR(X) L##X
#  define tstrcmp  wcscmp
#else
#  define _TSTR(X) X
#  define tstrcmp  strcmp
#endif

static inline std::string tstr2str(const TString &str) {
#ifdef _WIN32
    return SCL::wideToUtf8(str);
#else
    return str;
#endif
}

static inline TString str2tstr(const std::string &str) {
#ifdef _WIN32
    return SCL::utf8ToWide(str);
#else
    return str;
#endif
}

// ---------------------------------------- Commands ----------------------------------------

static int cmd_cpdir(const SCL::ParseResult &result) {
    const auto &src = str2tstr(result.value(0).toString());
    const auto &dest = str2tstr(result.value(1).toString());

    try {
        Utils::copyDirectory(src, dest);
    } catch (const std::exception &e) {
        u8printf("Error: %s\n", e.what());
        return -1;
    }
    return 0;
}

static int cmd_rmdir(const SCL::ParseResult &result) {
    TStringList fileNames;
    {
        const auto &dirsResult = result.values(0);
        fileNames.reserve(dirsResult.size());
        for (const auto &item : dirsResult) {
            fileNames.emplace_back(str2tstr(item.toString()));
        }
    }

    for (const auto &item : std::as_const(fileNames)) {
        if (!fs::is_directory(item)) {
            continue;
        }

        try {
            Utils::removeEmptyDirectories(item);
        } catch (const std::exception &e) {
            u8printf("Error: %s\n", e.what());
            return -1;
        }
    }
    return 0;
}

static int cmd_touch(const SCL::ParseResult &result) {
    const auto &file = str2tstr(result.value(0).toString());
    const auto &refFile = str2tstr(result.value(1).toString());

    // Check existence
    if (!fs::is_regular_file(file)) {
        u8printf("Error: \"%s\" is not a regular file\n", tstr2str(file).data());
        return -1;
    }

    if (!refFile.empty() && !fs::is_regular_file(refFile)) {
        u8printf("Error: \"%s\" is not a regular file\n", tstr2str(refFile).data());
        return -1;
    }

    // Get time
    Utils::FileTime t;
    if (!refFile.empty()) {
        t = Utils::fileTime(refFile);
        if (t.modifyTime == std::chrono::system_clock::time_point()) {
            u8printf("Error: failed to get time of \"%s\"\n", tstr2str(refFile).data());
            return -1;
        }
    } else {
        std::chrono::system_clock::time_point now = std::chrono::system_clock::now();
        t = {now, now, now};
    }

    // Set time
    try {
        Utils::setFileTime(file, t);
    } catch (const std::exception &e) {
        u8printf("Error: %s\n", e.what());
        return -1;
    }

    return 0;
}

static int cmd_configure(const SCL::ParseResult &result) {
    static const char STR_WARNING[] =
        R"(// Caution: This file is generated by CMake automatically during configure.
// WARNING!!! DO NOT EDIT THIS FILE MANUALLY!!!
// ALL YOUR MODIFICATIONS HERE WILL GET LOST AFTER RE-CONFIGURING!!!)";

    const auto &fileName = str2tstr(result.value(0).toString());

    // Add defines
    std::vector<std::string> defines;
    {
        const auto &definesResult = result.option("-D").allValues();
        defines.reserve(definesResult.size());
        for (const auto &item : definesResult) {
            defines.emplace_back(item.toString());
        }
    }

    // Generate definitions content
    std::string definitions;
    {
        std::stringstream ss;
        for (const auto &def : std::as_const(defines)) {
            size_t pos = def.find('=');
            if (pos != std::string::npos) {
                ss << "#define " << def.substr(0, pos) << " " << def.substr(pos + 1) << "\n";
            } else {
                ss << "#define " << def << "\n";
            }
        }
        definitions = ss.str();
    }

    // Calculate hash
    std::string hash;
    {
        uint8_t buf[32];
        calc_sha_256(buf, definitions.data(), definitions.size());

        std::stringstream ss;
        ss << std::hex << std::setfill('0');
        for (auto byte : buf) {
            ss << std::setw(2) << static_cast<int>(byte);
        }
        hash = ss.str();
    }

    // Read file
    do {
        // Check if file exists and has the same hash
        std::ifstream inFile(fileName);
        if (!inFile.is_open()) {
            break;
        }

        std::regex hashPattern(R"(^// SHA256: (\w+)$)");
        std::smatch match;
        std::string line;
        bool matched = false;

        int pp_cnt = 0;
        while (std::getline(inFile, line)) {
            if (line.empty())
                continue;

            if (line.starts_with('#')) {
                pp_cnt++; // Skip header guard
                if (pp_cnt > 2) {
                    break;
                }
                continue;
            }

            if (!line.starts_with("//"))
                break;

            if (std::regex_match(line, match, hashPattern)) {
                if (match[1] == hash) {
                    matched = true;
                }
                break;
            }
        }

        inFile.close();

        if (matched) {
            u8printf("Content matched. (%s)\n", hash.data());
            return 0; // Same hash found, no need to overwrite the file
        }

    } while (false);

    // Create file
    {
        std::ofstream outFile(fileName);
        if (!outFile.is_open()) {
            u8printf("Failed to open file \"%s\": %s.", tstr2str(fileName).data(),
                     std::error_code(errno, std::generic_category()).message().data());
            return -1;
        }

        // Header guard
        std::string guard = tstr2str(fileName);
        std::replace(guard.begin(), guard.end(), '.', '_');
        for (char &c : guard) {
            c = char(std::toupper(c));
        }

        outFile << "#ifndef " << guard << "\n";
        outFile << "#define " << guard << "\n\n";

        outFile << STR_WARNING << "\n\n";           // Warning
        outFile << "// SHA256: " << hash << "\n\n"; // Hash
        outFile << definitions << "\n";             // Definitions
        outFile << "#endif // " << guard << "\n";   // Header guard end

        outFile.close();
    }

    return 0;
}

static int cmd_incsync(const SCL::ParseResult &result) {
    bool copy = result.optionIsSet("-c");
    bool all = !result.optionIsSet("-n");
    bool standard = result.optionIsSet("-s");

    const fs::path &src = str2tstr(result.value(0).toString());
    const fs::path &dest = str2tstr(result.value(1).toString());
    if (!fs::is_directory(src)) {
        u8printf("Error: \"%s\" is not a directory.\n", tstr2str(src).data());
        return -1;
    }

    // Add includes
    std::vector<std::pair<TString, TString>> includes;
    {
        const auto &includeResult = result.option("-i");
        int cnt = includeResult.count();
        includes.reserve(cnt + 1);

        // Add standard
        if (standard) {
            includes.emplace_back(_TSTR(R"(.*?_p\..+$)"), _TSTR("private"));
        }

        for (int i = 0; i < cnt; ++i) {
            includes.emplace_back(str2tstr(includeResult.value(0, i).toString()),
                                  str2tstr(includeResult.value(1, i).toString()));
        }
    }

    // Add excludes
    TStringList excludes;
    {
        const auto &excludeResult = result.option("-e").allValues();
        excludes.reserve(excludeResult.size());
        for (const auto &item : excludeResult) {
            excludes.emplace_back(str2tstr(item.toString()));
        }
    }

    try {
        // Remove target directory
        if (fs::exists(dest)) {
            std::filesystem::remove_all(dest);
        }

        for (const auto &entry : fs::recursive_directory_iterator(src)) {
            if (entry.is_regular_file()) {
                const auto &path = entry.path();
                if (!(path.extension() == _TSTR(".h") || path.extension() == _TSTR(".hpp"))) {
                    continue;
                }

                // Get subdirectory
                std::filesystem::path subdir;
                for (const auto &pair : includes) {
                    const TString &pathString = path;
                    if (std::regex_search(pathString.begin(), pathString.end(),
                                          std::basic_regex<TChar>(pair.first))) {
                        subdir = pair.second;
                    }
                }

                if (!all && subdir.empty())
                    continue;

                // Check if should exclude
                bool skip = false;
                for (const auto &pattern : excludes) {
                    const TString &pathString = path;
                    if (std::regex_search(pathString.begin(), pathString.end(),
                                          std::basic_regex<TChar>(pattern))) {
                        skip = true;
                        break;
                    }
                }

                if (skip)
                    continue;

                const fs::path &targetDir = (TString(path.stem())
                                                 .substr(path.stem().string().length() - 2, 2)
                                                 .ends_with(_TSTR("_p")) &&
                                             !subdir.empty())
                                                ? (dest / subdir)
                                                : (dest);

                // Create directory
                if (!fs::exists(targetDir)) {
                    fs::create_directories(targetDir);
                }

                auto targetPath = targetDir / path.filename();
                if (copy) {
                    // Copy
                    try {
                        fs::copy(path, targetPath, fs::copy_options::overwrite_existing);
                    } catch (const std::exception &e) {
                        u8printf("Warning: copy file \"%s\" failed: %s\n", tstr2str(path).data(),
                                 e.what());
                        continue;
                    }
                } else {
                    // Make relative reference
                    auto rel = fs::relative(path, targetDir).string();
                    std::replace(rel.begin(), rel.end(), '\\', '/');

                    // Create file
                    std::ofstream outFile(targetPath);
                    if (!outFile.is_open())
                        continue;
                    outFile << "#include \"" << rel << "\"" << std::endl;
                    outFile.close();
                }

                // Set the timestamp
                Utils::syncFileTime(targetPath, path);
            }
        }
    } catch (const std::exception &e) {
        u8printf("Error: %s\n", e.what());
        return -1;
    }

    return 0;
}

static int cmd_deploy(const SCL::ParseResult &result) {
    return 0;
}

int main(int argc, char *argv[]) {
    SCL::Command cpdirCommand = []() {
        SCL::Command command("cpdir", "Copy contents of a directory if different");
        command.addArguments({
            SCL::Argument("src", "Source directory"),
            SCL::Argument("dest", "Destination directory"),
        });
        command.setHandler(cmd_cpdir);
        return command;
    }();

    SCL::Command rmdirCommand = []() {
        SCL::Command command("rmdir", "Remove all empty directories");
        command.addArguments({
            SCL::Argument("dir", "Directories").multi(),
        });
        command.setHandler(cmd_rmdir);
        return command;
    }();

    SCL::Command touchCommand = []() {
        SCL::Command command("touch", "Update file timestamp");
        command.addArguments({
            SCL::Argument("file", "File to update time stamp"),
            SCL::Argument("ref file", "Reference file", false),
        });
        command.setHandler(cmd_touch);
        return command;
    }();

    SCL::Command configureCommand = []() {
        SCL::Command command("configure", "Generate configuration header.");
        command.addArgument(SCL::Argument("output file", "Output header path"));
        command.addOptions({
            SCL::Option({"-D", "--define"}, R"(Define a variable, format: "key" or "key=value")")
                .arg("expr")
                .multi()
                .short_match(SCL::Option::ShortMatchSingleChar),
        });
        command.setHandler(cmd_configure);
        return command;
    }();

    SCL::Command incsyncCommand = []() {
        SCL::Command command(SCL::appName(), "Reorganize the header directory structure.");
        command.addArguments({
            SCL::Argument("src dir", "Source files directory"),
            SCL::Argument("dest dir", "Destination directory"),
        });
        command.addOptions({
            SCL::Option({"-i", "--include"}, "Add a path pattern and corresponding subdirectory")
                .arg("regex")
                .arg("subdir")
                .multi(),
            SCL::Option({"-e", "--exclude"}, "Exclude a path pattern").arg("regex").multi(),
            SCL::Option({"-s", "--standard"}, "Add standard public-private name pattern"),
            SCL::Option({"-n", "--not-all"}, "Ignore unclassified files"),
            SCL::Option({"-c", "--copy"}, "Copy files rather than indirect reference"),
        });
        command.setHandler(cmd_incsync);
        return command;
    }();

    SCL::Command deployCommand = []() {
        SCL::Command command("deploy", "Resolve and deploy " OS_EXECUTABLE " files' dependencies.");
        command.addArguments({
            SCL::Argument("file", OS_EXECUTABLE "(s)"),
        });
        command.addOptions({
            SCL::Option({"-o", "--out"}, "Set the output directory, defult to current directory")
                .arg("dir"),
#ifdef _WIN32
            SCL::Option({"-L", "--linkdir"}, "Add a library searching path")
                .arg("dir")
                .multi()
                .short_match(SCL::Option::ShortMatchSingleChar),
#endif
            SCL::Option({"-e", "--exclude"}, "Exclude a path pattern").arg("regex").multi(),
            SCL::Option({"-f", "--force"}, "Force overwrite existing files"),
        });
        command.setHandler(cmd_deploy);
        return command;
    }();

    SCL::Command rootCommand(SCL::appName(), "Cross-platform core utility commands.");
    rootCommand.addCommands({
        cpdirCommand,
        rmdirCommand,
        touchCommand,
        configureCommand,
        incsyncCommand,
        deployCommand,
    });
    rootCommand.addVersionOption(TOOL_VERSION);
    rootCommand.addHelpOption(true, true);
    rootCommand.setHandler([](const SCL::ParseResult &result) -> int {
        result.showHelpText();
        return 0;
    });

    SCL::Parser parser(rootCommand);
    parser.setPrologue(TOOL_DESC);

#ifdef _WIN32
    std::ignore = argc;
    std::ignore = argv;
    return parser.invoke(SCL::commandLineArguments());
#else
    return parser.invoke(argc, argv);
#endif
}