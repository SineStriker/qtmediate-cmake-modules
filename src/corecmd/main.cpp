#include <iostream>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <regex>
#include <set>
#include <stdexcept>
#include <iomanip>

#include <syscmdline/parser.h>
#include <syscmdline/system.h>

#include "sha-256.h"
#include "utils.h"

namespace SCL = SysCmdLine;

namespace fs = std::filesystem;

using SCL::u8printf;

static constexpr const char STR_WARNING[] =
    R"(// Caution: This file is generated by CMake automatically during configure.
// WARNING!!! DO NOT EDIT THIS FILE MANUALLY!!!
// ALL YOUR MODIFICATIONS HERE WILL GET LOST AFTER RE-CONFIGURING!!!)";

// ---------------------------------------- Definitions ----------------------------------------

#ifdef _WIN32
#  define OS_EXECUTABLE "Windows PE"
#elif defined(__APPLE__)
#  define OS_EXECUTABLE "Mach-O"
#else
#  define OS_EXECUTABLE "ELF"
#endif

#ifdef _WIN32
using TChar = wchar_t;
using TString = std::wstring;
#else
using TChar = char;
using TString = std::string;
#endif

using TStringList = std::vector<TString>;
using TStringSet = std::set<TString>;

#ifdef _WIN32
#  define _TSTR(X) L##X
#  define tstrcmp  wcscmp
#else
#  define _TSTR(X) X
#  define tstrcmp  strcmp
#endif

// ---------------------------------------- Functions ----------------------------------------

static inline std::string tstr2str(const TString &str) {
#ifdef _WIN32
    return SCL::wideToUtf8(str);
#else
    return str;
#endif
}

static inline TString str2tstr(const std::string &str) {
#ifdef _WIN32
    return SCL::utf8ToWide(str);
#else
    return str;
#endif
}

static std::string time2str(const std::chrono::system_clock::time_point &t) {
    std::time_t t2 = std::chrono::system_clock::to_time_t(t);
    std::string s(30, '\0');
    std::strftime(s.data(), s.size(), "%Y-%m-%d %H:%M:%S", std::localtime(&t2));
    return s;
}

static bool removeEmptyDirectories(const fs::path &path, bool verbose) {
    bool isEmpty = true;
    for (const auto &entry : fs::directory_iterator(path)) {
        if (fs::is_directory(entry.path()) && removeEmptyDirectories(entry.path(), verbose)) {
            if (verbose) {
                u8printf("Remove %s\n", tstr2str(path).data());
            }

            // Empty directory
            fs::remove(entry.path());
        }

        // File or non-empty directory
        isEmpty = false;
    }
    return isEmpty;
}

static bool copyFile(const fs::path &file, const fs::path &dest, bool symlink, bool force,
                     bool verbose) {
    auto target = dest / fs::path(file).filename();
    if (fs::exists(target)) {
        if (Utils::cleanPath(target) == Utils::cleanPath(file))
            return false; // Same file

        if (!force && Utils::fileTime(target).modifyTime >= Utils::fileTime(file).modifyTime)
            return false; // Not updated
    } else if (!fs::is_directory(dest)) {
        fs::create_directories(dest);
    }

    if (symlink && fs::is_symlink(file)) {
        if (verbose) {
            u8printf("Link %s\n", tstr2str(target).data());
        }
        fs::copy_symlink(file, target);
    } else {
        if (verbose) {
            u8printf("Copy %s\n", tstr2str(target).data());
        }
        fs::copy(file, dest, fs::copy_options::overwrite_existing);
        Utils::syncFileTime(target, file); // Sync time for each file
    }

    return true;
}

static void copyDirectory(const fs::path &rootSourceDir, const fs::path &sourceDir,
                          const fs::path &destDir, bool force, bool verbose,
                          const std::function<bool(const fs::path &)> &ignore = {}) {
    fs::create_directories(destDir); // Ensure the destination directory exists

    for (const auto &dirEntry : fs::directory_iterator(sourceDir)) {
        const auto &sourcePath = dirEntry.path();
        if (ignore && ignore(sourcePath))
            continue;

        if (fs::is_symlink(sourcePath)) {
            auto linkPath = fs::canonical(sourcePath);

            // Copy if symlink points inside the source directory
            copyFile(sourcePath, destDir, linkPath.string().starts_with(rootSourceDir.string()),
                     force, verbose);
        } else if (fs::is_regular_file(sourcePath)) {
            copyFile(sourcePath, destDir, false, force, verbose);
        } else if (fs::is_directory(sourcePath)) {
            copyDirectory(rootSourceDir, sourcePath, destDir / sourcePath.filename(), force,
                          verbose, ignore);
        }
    }
}

static std::string standardError(int code = errno) {
    return std::error_code(code, std::generic_category()).message();
}

#ifdef __APPLE__
static fs::path lib2framework(fs::path path, const fs::path &fallback = {}) {
    // Ensure the path has at least three ancestors (including root)
    for (int i = 0; i < 3; ++i) {
        if (!path.has_parent_path())
            return fallback;
        path = path.parent_path();
    }
    // Check if the ancestor's extension is ".framework"
    if (path.extension() == ".framework")
        return path;
    return fallback;
}

static fs::path framework2lib(fs::path path, const fs::path &fallback = {}) {
    try {
        return fs::canonical(path / path.stem());
    } catch (...) {
    }
    return fallback;
}

static fs::path framework2lib_debug(fs::path path, const fs::path &fallback = {}) {
    try {
        return fs::canonical(path / (path.stem().string() + "_debug"));
    } catch (...) {
    }
    return fallback;
}
#endif

#ifndef _WIN32

// Copy library files and symlinks, returns the real library file
fs::path copyCanonical(const fs::path &path, const fs::path &dest, bool force, bool verbose) {
    fs::path target;
    if (fs::is_symlink(path)) {
        auto linkPath = fs::canonical(path);
        copyFile(linkPath, dest, false, force, verbose); // Copy real file
        copyFile(path, dest, true, force, verbose);      // Copy link file
        target = dest / linkPath.filename();
    } else {
        copyFile(path, dest, false, force, verbose); // Copy file
        target = dest / path.filename();
    }
    return target;
};

#endif

static inline fs::path toFramework(const fs::path &path) {
    return
#ifdef __APPLE__
        lib2framework(path, path)
#else
        path
#endif
            ;
};

static inline fs::path fromFramework(const fs::path &path) {
    return
#ifdef __APPLE__
        framework2lib(path, path)
#else
        path
#endif
            ;
};

// ---------------------------------------- Commands ----------------------------------------

static int cmd_cpdir(const SCL::ParseResult &result) {
    bool force = result.optionIsSet("-f");
    bool verbose = result.optionIsSet("-V");
    const auto &src = fs::absolute(str2tstr(result.value(0).toString()));
    const auto &dest = fs::absolute(str2tstr(result.value(1).toString()));
    copyDirectory(src, src, dest, force, verbose);
    return 0;
}

static int cmd_rmdir(const SCL::ParseResult &result) {
    bool verbose = result.optionIsSet("-V");
    std::vector<fs::path> dirs;
    {
        const auto &dirsResult = result.values(0);
        dirs.reserve(dirsResult.size());
        for (const auto &item : dirsResult) {
            dirs.emplace_back(fs::absolute(str2tstr(item.toString())));
        }
    }

    for (const auto &item : std::as_const(dirs)) {
        if (!fs::is_directory(item)) {
            continue;
        }
        removeEmptyDirectories(item, verbose);
    }
    return 0;
}

static int cmd_touch(const SCL::ParseResult &result) {
    bool verbose = result.optionIsSet("-V");

    const auto &file = str2tstr(result.value(0).toString());
    const auto &refFile = str2tstr(result.value(1).toString());

    // Check existence
    if (!fs::is_regular_file(file)) {
        throw std::runtime_error("not a regular file: \"" + tstr2str(file) + "\"");
    }

    if (!refFile.empty() && !fs::is_regular_file(refFile)) {
        throw std::runtime_error("not a regular file: \"" + tstr2str(refFile) + "\"");
    }

    // Get time
    Utils::FileTime t;
    if (!refFile.empty()) {
        t = Utils::fileTime(refFile);
    } else {
        auto now = std::chrono::system_clock::now();
        t = {now, now, now};
    }

    // Set time
    if (verbose) {
        u8printf("Set A-Time: %s\n", time2str(t.accessTime).data());
        u8printf("Set M-Time: %s\n", time2str(t.modifyTime).data());
        u8printf("Set C-Time: %s\n", time2str(t.statusChangeTime).data());
    }
    Utils::setFileTime(file, t);
    return 0;
}

static int cmd_configure(const SCL::ParseResult &result) {
    bool verbose = result.optionIsSet("-V");
    const auto &fileName = str2tstr(result.value(0).toString());

    // Add defines
    std::vector<std::string> defines;
    {
        const auto &definesResult = result.option("-D").allValues();
        defines.reserve(definesResult.size());
        for (const auto &item : definesResult) {
            defines.emplace_back(item.toString());
        }
    }

    // Generate definitions content
    std::string definitions;
    {
        std::stringstream ss;
        for (const auto &def : std::as_const(defines)) {
            size_t pos = def.find('=');
            if (pos != std::string::npos) {
                ss << "#define " << def.substr(0, pos) << " " << def.substr(pos + 1) << "\n";
            } else {
                ss << "#define " << def << "\n";
            }
        }
        definitions = ss.str();
    }

    // Calculate hash
    std::string hash;
    {
        uint8_t buf[32];
        calc_sha_256(buf, definitions.data(), definitions.size());

        std::stringstream ss;
        ss << std::hex << std::setfill('0');
        for (auto byte : buf) {
            ss << std::setw(2) << static_cast<int>(byte);
        }
        hash = ss.str();
    }

    // Read file
    do {
        // Check if file exists and has the same hash
        std::ifstream inFile(fileName);
        if (!inFile.is_open()) {
            break;
        }

        std::regex hashPattern(R"(^// SHA256: (\w+)$)");
        std::smatch match;
        std::string line;
        bool matched = false;

        int pp_cnt = 0;
        while (std::getline(inFile, line)) {
            if (line.empty())
                continue;

            if (line.starts_with('#')) {
                pp_cnt++; // Skip header guard
                if (pp_cnt > 2) {
                    break;
                }
                continue;
            }

            if (!line.starts_with("//"))
                break;

            if (std::regex_match(line, match, hashPattern)) {
                if (match[1] == hash) {
                    matched = true;
                }
                break;
            }
        }

        inFile.close();

        if (matched) {
            if (verbose) {
                SCL::u8debug(SCL::MessageType::MT_Warning, true, "Content matched. (%s)\n",
                             hash.data());
            }
            return 0; // Same hash found, no need to overwrite the file
        }

    } while (false);

    // Create file
    {
        // Create directory if needed
        if (auto dir = fs::path(fileName).parent_path(); !fs::is_directory(dir)) {
            fs::create_directories(dir);
        }

        std::ofstream outFile(fileName);
        if (!outFile.is_open()) {
            throw std::runtime_error("failed to open file \"" + tstr2str(fileName) +
                                     "\": " + standardError());
        }

        // Header guard
        std::string guard = tstr2str(fs::path(fileName).filename());
        std::replace(guard.begin(), guard.end(), '.', '_');
        for (char &c : guard) {
            c = char(std::toupper(c));
        }

        outFile << "#ifndef " << guard << "\n";
        outFile << "#define " << guard << "\n\n";

        outFile << STR_WARNING << "\n\n";           // Warning
        outFile << "// SHA256: " << hash << "\n\n"; // Hash
        outFile << definitions << "\n";             // Definitions
        outFile << "#endif // " << guard << "\n";   // Header guard end

        outFile.close();
    }

    if (verbose) {
        u8printf("SHA256: %s\n", hash.data());
    }

    return 0;
}

static int cmd_incsync(const SCL::ParseResult &result) {
    bool verbose = result.optionIsSet("-V");

    bool copy = result.optionIsSet("-c");
    bool all = !result.optionIsSet("-n");
    bool standard = result.optionIsSet("-s");

    const fs::path &src = str2tstr(result.value(0).toString());
    const fs::path &dest = str2tstr(result.value(1).toString());
    if (!fs::is_directory(src)) {
        throw std::runtime_error("not a directory: \"" + tstr2str(src) + "\"");
    }

    // Add includes
    std::vector<std::pair<TString, TString>> includes;
    {
        const auto &includeResult = result.option("-i");
        int cnt = includeResult.count();
        includes.reserve(cnt + 1);

        // Add standard
        if (standard) {
            includes.emplace_back(_TSTR(R"(.*?_p\..+$)"), _TSTR("private"));
        }

        for (int i = 0; i < cnt; ++i) {
            includes.emplace_back(str2tstr(includeResult.value(0, i).toString()),
                                  str2tstr(includeResult.value(1, i).toString()));
        }
    }

    // Add excludes
    TStringList excludes;
    {
        const auto &excludeResult = result.option("-e").allValues();
        excludes.reserve(excludeResult.size());
        for (const auto &item : excludeResult) {
            excludes.emplace_back(str2tstr(item.toString()));
        }
    }

    // Remove target directory
    if (fs::exists(dest)) {
        std::filesystem::remove_all(dest);
    }

    for (const auto &entry : fs::recursive_directory_iterator(src)) {
        if (entry.is_regular_file()) {
            const auto &path = entry.path();
            if (!(path.extension() == _TSTR(".h") || path.extension() == _TSTR(".hpp"))) {
                continue;
            }

            // Get subdirectory
            std::filesystem::path subdir;
            for (const auto &pair : includes) {
                const TString &pathString = path;
                if (std::regex_search(pathString.begin(), pathString.end(),
                                      std::basic_regex<TChar>(pair.first))) {
                    subdir = pair.second;
                }
            }

            if (!all && subdir.empty())
                continue;

            // Check if should exclude
            bool skip = false;
            for (const auto &pattern : excludes) {
                const TString &pathString = path;
                if (std::regex_search(pathString.begin(), pathString.end(),
                                      std::basic_regex<TChar>(pattern))) {
                    skip = true;
                    break;
                }
            }

            if (skip)
                continue;

            const fs::path &targetDir = subdir.empty() ? dest : (dest / subdir);

            // Create directory
            if (!fs::exists(targetDir)) {
                fs::create_directories(targetDir);
            }

            auto targetPath = targetDir / path.filename();
            if (verbose) {
                u8printf("Create %s\n", tstr2str(targetPath).data());
            }

            if (copy) {
                // Copy
                fs::copy(path, targetPath, fs::copy_options::overwrite_existing);
            } else {
                // Make relative reference
                std::string rel = tstr2str(fs::relative(path, targetDir));

#ifdef _WIN32
                // Replace separator
                std::replace(rel.begin(), rel.end(), '\\', '/');
#endif

                // Create file
                std::ofstream outFile(targetPath);
                if (!outFile.is_open())
                    continue;
                outFile << "#include \"" << rel << "\"" << std::endl;
                outFile.close();
            }

            // Set timestamp
            Utils::syncFileTime(targetPath, path);
        }
    }

    return 0;
}

static int cmd_deploy(const SCL::ParseResult &result) {
    bool verbose = result.optionIsSet("-V");
    bool force = result.optionIsSet("-f");
    bool standard = result.optionIsSet("-s");
#ifdef __APPLE__
    bool debug = result.optionIsSet("-d");
#endif

    fs::path dest = fs::current_path(); // Default to current path
    if (result.optionIsSet("-o")) {
        dest = Utils::cleanPath(fs::absolute(str2tstr(result.valueForOption("-o").toString())));
    }

    // Add file names
    std::set<fs::path> orgFiles;
    {
        const auto &files = result.values(0);
        for (const auto &item : files) {
            orgFiles.insert(toFramework(Utils::cleanPath(fs::absolute(str2tstr(item.toString())))));
        }
    }

    // Add extra org files
    std::vector<std::pair<fs::path, fs::path>> extraOrgFiles;
    {
        const auto &copiesResult = result.option("-c");
        int cnt = copiesResult.count();
        extraOrgFiles.reserve(cnt);
        for (int i = 0; i < cnt; ++i) {
            extraOrgFiles.emplace_back(
                toFramework(
                    Utils::cleanPath(fs::absolute(str2tstr(copiesResult.value(0, i).toString())))),
                Utils::cleanPath(fs::absolute(str2tstr(copiesResult.value(1, i).toString()))));
        }
    }

#ifdef _WIN32
    // Add searching paths
    std::vector<fs::path> searchingPaths;
    {
        const auto &linkResult = result.option("-L").allValues();

        std::vector<fs::path> tmp;
        tmp.reserve(linkResult.size() + orgFiles.size());

        // Add file paths
        for (const auto &item : std::as_const(orgFiles)) {
            tmp.emplace_back(fs::path(item).parent_path());
        }

        // Add searching paths
        for (const auto &item : linkResult) {
            tmp.emplace_back(Utils::cleanPath(fs::absolute(str2tstr(item.toString()))));
        }

        // Remove duplications
        std::set<fs::path> visited;
        for (const auto &item : std::as_const(tmp)) {
            if (!fs::is_directory(item))
                continue;

            if (visited.contains(item)) {
                continue;
            }
            visited.insert(item);
            searchingPaths.emplace_back(item);
        }
    }
#endif

    // Add excludes
    TStringList excludes;
    {
        const auto &excludeResult = result.option("-e").allValues();
        excludes.reserve(excludeResult.size());
        for (const auto &item : excludeResult) {
            excludes.emplace_back(str2tstr(item.toString()));
        }
    }

    // Deploy
    std::vector<fs::path> dependencies;
    {
        std::set<fs::path> allOrgFileNames;
        for (const auto &item : std::as_const(orgFiles)) {
            allOrgFileNames.insert(item.filename());
        }
        for (const auto &pair : std::as_const(extraOrgFiles)) {
            allOrgFileNames.insert(pair.first.filename());
        }

        const auto &getFilesDeps =
            [](const std::vector<fs::path> &paths) -> std::vector<std::string> {
            std::set<std::string> libs;
            for (const auto &path : std::as_const(paths)) {
                const auto &deps = Utils::resolveExecutableDependencies(fromFramework(path));
                for (const auto &item : std::as_const(deps)) {
                    libs.insert(item);
                }
            }
            return {libs.begin(), libs.end()};
        };

        std::set<fs::path> visited;
        std::vector<fs::path> stack = {orgFiles.begin(), orgFiles.end()};

        // Mark original files as visited
        for (const auto &item : std::as_const(orgFiles)) {
            visited.insert(item.filename());
        }
        for (const auto &pair : std::as_const(extraOrgFiles)) {
            visited.insert(pair.first.filename());
            stack.push_back(pair.first);
        }

        // Search for dependencies recursively
        while (!stack.empty()) {
            auto libs = getFilesDeps(stack);
            stack.clear();

            // Search dependencies
            for (const auto &lib : std::as_const(libs)) {
                TString fileName = Utils::toLower(TString(toFramework(lib).filename()));

                // Ignore files in standard mode
                if ((standard && (
#ifdef _WIN32
                                     fileName.starts_with(_TSTR("vcruntime")) ||
                                     fileName.starts_with(_TSTR("msvcp")) ||
                                     fileName.starts_with(_TSTR("concrt")) ||
                                     fileName.starts_with(_TSTR("vccorlib")) ||
                                     fileName.starts_with(_TSTR("ucrtbase"))
#elif defined(__APPLE__)
                                     fileName.starts_with("libc++") ||
                                     fileName.starts_with("libSystem") ||
                                     fileName.starts_with("/System")
#else
                                     fileName.starts_with("libstdc++") ||
                                     fileName.starts_with("libgcc") ||
                                     fileName.starts_with("libglib") ||
                                     fileName.starts_with("libpthread") ||
                                     fileName.starts_with("libgthread") ||
                                     fileName.starts_with("libicu") ||
                                     fileName.starts_with("libc.so") ||
                                     fileName.starts_with("libc-") ||
                                     fileName.starts_with("libdl.so") ||
                                     fileName.starts_with("libdl-")
#endif
                                         )) ||
#ifdef _WIN32
                    (fs::exists(_TSTR("C:\\Windows\\") + fileName) ||
                     fs::exists(_TSTR("C:\\Windows\\system32\\") + fileName) ||
                     fs::exists(_TSTR("C:\\Windows\\SysWow64\\") + fileName) ||
                     fileName.starts_with(_TSTR("api-ms-win-")) ||
                     fileName.starts_with(_TSTR("ext-ms-win-"))) ||
#endif
                    visited.contains(fileName)) {
                    continue;
                }
                visited.insert(fileName);

#ifdef _WIN32
                // Search in specified searching paths on Windows
                fs::path path;
                for (const auto &dir : std::as_const(searchingPaths)) {
                    fs::path targetPath = dir / fs::path(lib);
                    if (fs::exists(targetPath)) {
                        path = targetPath;
                        break;
                    }
                }

                if (path.empty()) {
                    continue;
                }
#else
                const fs::path &path = Utils::cleanPath(toFramework(lib));
#endif

                // Ignore orginal file
                if (allOrgFileNames.contains(path.filename()))
                    continue;

                bool skip = false;
                for (const auto &pattern : std::as_const(excludes)) {
                    const TString &pathString = path;
                    if (std::regex_search(pathString.begin(), pathString.end(),
                                          std::basic_regex<TChar>(pattern))) {
                        skip = true;
                        break;
                    }
                }

                if (skip)
                    continue;

                dependencies.push_back(path);

                // Push to stack and resolve in next loop
                stack.push_back(path);
            }
        }
    }

    // Deploy

#ifdef _WIN32
    // Windows
    // Only need to copy the libraries.

    // Copy original files
    for (const auto &pair : std::as_const(extraOrgFiles)) {
        copyFile(pair.first, pair.second, false, force, verbose);
    }

    // Copy dependencies
    for (const auto &file : std::as_const(dependencies)) {
        copyFile(file, dest, false, force, verbose);
    }
#else
    // Unix
    // Copy libraries and fix rpaths, and may need to deploy interpreter on Linux.

    const auto &fixRPaths = [verbose](const std::string &file,
                                      const std::vector<std::string> &paths) {
        if (verbose) {
            u8printf("Fix rpath: %s\n", file.data());
        }
        Utils::setFileRPaths(file, paths);
    };

#  if defined(__APPLE__)
    // Ignore Header files and unused library
    const auto &frameworkIgnore = [](const fs::path &path, const fs::path &frameworkName,
                                     bool debug) -> bool {
        if (debug) {
            if (path.filename() == frameworkName)
                return true;
        } else {
            if (path.filename() == frameworkName.string() + "_debug")
                return true;
        }
        return fs::is_directory(path) && path.filename() == "Headers" &&
               fs::is_directory(path.parent_path() / "Resources");
    };

    // The framework is supposed to place at the right place
    // We don't take care of the special rpaths
    const auto &fixFrameworkRPaths = [fixRPaths](const fs::path &path) {
        fixRPaths(path, {
                            "@executable_path/../Frameworks",
                            "@loader_path/Frameworks",
                            "@loader_path/../../..",
                        });
    };

    // Copy original files
    auto targetOrgFiles = orgFiles;
    for (const auto &pair : std::as_const(extraOrgFiles)) {
        const auto &file = pair.first;
        fs::path targetPath;
        if (fs::is_directory(file)) {
            const auto &name = file.stem();
            targetPath = pair.second / file.filename();
            copyDirectory(
                file, file, targetPath, force, verbose,
                [&](const fs::path &path) -> bool { return frameworkIgnore(path, name, debug); });
        } else {
            targetPath = copyCanonical(file, pair.second, force, verbose);
        }
        targetOrgFiles.insert(targetPath);
    }

    // Copy dependencies
    std::set<fs::path> targetDependencies;
    for (const auto &file : std::as_const(dependencies)) {
        fs::path targetPath;
        if (fs::is_directory(file)) {
            const auto &name = file.stem();
            targetPath = dest / file.filename();
            copyDirectory(
                file, file, targetPath, force, verbose,
                [&](const fs::path &path) -> bool { return frameworkIgnore(path, name, debug); });
        } else {
            targetPath = copyCanonical(file, dest, force, verbose);
        }
        targetDependencies.insert(targetPath);
    }

    // Fix rpath for original files
    for (const auto &file : std::as_const(targetOrgFiles)) {
        if (file.extension() == ".dylib") {
            fixRPaths(file, {"@loader_path" + fs::relative(dest, file.parent_path()).string()});
        } else {
            fs::path lib = framework2lib(file);
            if (!lib.empty()) {
                fixFrameworkRPaths(lib);
            }

            fs::path libDebug = framework2lib_debug(file);
            if (!libDebug.empty()) {
                fixFrameworkRPaths(libDebug);
            }
        }
    }

    // Fix rpath for dependencies
    for (const auto &file : std::as_const(targetDependencies)) {
        if (file.extension() == ".dylib") {
            fixRPaths(file, {"@loader_path"});
        } else {
            fs::path lib = framework2lib(file);
            if (!lib.empty()) {
                fixFrameworkRPaths(lib);
            }

            fs::path libDebug = framework2lib_debug(file);
            if (!libDebug.empty()) {
                fixFrameworkRPaths(libDebug);
            }
        }
    }

#  else
    // Copy original files
    auto targetOrgFiles = orgFiles;
    for (const auto &pair : std::as_const(extraOrgFiles)) {
        std::string targetPath = copySharedLibraries(pair.first, pair.second);
        targetOrgFiles.insert(targetPath);
    }

    // Copy dependencies
    std::set<fs::path> targetDependencies;
    for (const auto &dep : std::as_const(dependencies)) {
        std::string targetPath = copySharedLibraries(dep, dest);

        // libc.so is a shell script
        if (fs::path(targetPath).filename() != "libc.so") {
            targetDependencies.insert(targetPath);
        }
    }

    // Fix rpath for original files
    for (const auto &file : std::as_const(targetOrgFiles)) {
        if (verbose) {
            u8printf("Fix rpath: %s\n", file.string().data());
        }
        fixRPaths(file, {"$ORIGIN/" + fs::relative(dest, file.parent_path()).string()});
    }

    // Fix rpath for dependencies
    for (const auto &file : std::as_const(targetDependencies)) {
        if (verbose) {
            u8printf("Fix rpath: %s\n", file.string().data());
        }
        fixRPaths(file, {"$ORIGIN"});
    }

    // Fix interpreter
    do {
        if (standard) {
            break;
        }

        fs::path interpreter;
        for (const auto &file : std::as_const(targetOrgFiles)) {
            interpreter = Utils::getInterpreter(file);
            if (!interpreter.empty())
                break;
        }
        if (interpreter.empty()) {
            for (const auto &dep : std::as_const(targetDependencies)) {
                interpreter = Utils::getInterpreter(dep);
                if (!interpreter.empty())
                    break;
            }
        }
        if (interpreter.empty())
            break;

        // Copy interpreter
        copyCanonical(interpreter, dest, force, verbose);

        std::string interpreterName = interpreter.filename();
        interpreter = dest / interpreterName;

        // Set interpreter for original files
        for (const auto &file : std::as_const(targetOrgFiles)) {
            fs::path filePath(file);
            fs::path relativePath = fs::relative(interpreter, filePath.parent_path());
            if (verbose) {
                u8printf("Set interpreter: %s\n", file.string().data());
            }

            Utils::setFileInterpreter(file, "$ORIGIN/" + relativePath.string());
        }

        // Set interpreter for dependencies
        for (const auto &dep : std::as_const(targetDependencies)) {
            if (verbose) {
                u8printf("Set interpreter: %s\n", dep.string().data());
            }
            Utils::setFileInterpreter(dep, "$ORIGIN/" + interpreterName);
        }
    } while (false);
#  endif
#endif
    return 0;
}

int main(int argc, char *argv[]) {
    // Shared option
    static SCL::Option verbose({"-V", "--verbose"}, "Show verbose");

    SCL::Command cpdirCommand = []() {
        SCL::Command command("cpdir", "Copy contents of a directory");
        command.addArguments({
            SCL::Argument("src", "Source directory"),
            SCL::Argument("dest", "Destination directory"),
        });
        command.addOption(SCL::Option({"-f", "--force"}, "Force overwrite existing files"));
        command.addOptions({verbose});
        command.setHandler(cmd_cpdir);
        return command;
    }();

    SCL::Command rmdirCommand = []() {
        SCL::Command command("rmdir", "Remove all empty directories");
        command.addArguments({
            SCL::Argument("dir", "Directories").multi(),
        });
        command.addOption(verbose);
        command.setHandler(cmd_rmdir);
        return command;
    }();

    SCL::Command touchCommand = []() {
        SCL::Command command("touch", "Update file timestamp");
        command.addArguments({
            SCL::Argument("file", "File to update time stamp"),
            SCL::Argument("ref file", "Reference file", false),
        });
        command.addOption(verbose);
        command.setHandler(cmd_touch);
        return command;
    }();

    SCL::Command configureCommand = []() {
        SCL::Command command("configure", "Generate configuration header");
        command.addArgument(SCL::Argument("output file", "Output header path"));
        command.addOptions({
            SCL::Option({"-D", "--define"}, R"(Define a variable, format: "key" or "key=value")")
                .arg("expr")
                .multi()
                .short_match(SCL::Option::ShortMatchSingleChar),
        });
        command.addOption(verbose);
        command.setHandler(cmd_configure);
        return command;
    }();

    SCL::Command incsyncCommand = []() {
        SCL::Command command("incsync", "Reorganize the header directory structure");
        command.addArguments({
            SCL::Argument("src dir", "Source files directory"),
            SCL::Argument("dest dir", "Destination directory"),
        });
        command.addOptions({
            SCL::Option({"-i", "--include"}, "Add a path pattern and corresponding subdirectory")
                .arg("regex")
                .arg("subdir")
                .multi(),
            SCL::Option({"-e", "--exclude"}, "Exclude a path pattern").arg("regex").multi(),
            SCL::Option({"-s", "--standard"}, "Add standard public-private name pattern"),
            SCL::Option({"-n", "--not-all"}, "Ignore unclassified files"),
            SCL::Option({"-c", "--copy"}, "Copy files rather than indirect reference"),
        });
        command.addOption(verbose);
        command.setHandler(cmd_incsync);
        return command;
    }();

    SCL::Command deployCommand = []() {
        SCL::Command command("deploy", "Resolve and deploy " OS_EXECUTABLE " files' dependencies");
        command.addArguments({
            SCL::Argument("file", OS_EXECUTABLE " file(s)").multi(),
        });
        command.addOptions({
            SCL::Option({"-c", "--copy"}, "Additional " OS_EXECUTABLE " file(s) to copy")
                .arg("src")
                .arg("dir")
                .multi()
                .prior(SCL::Option::IgnoreMissingArguments),
            SCL::Option({"-o", "--out"},
                        "Set output directory of dependencies, defult to current directory")
                .arg("dir"),
#ifdef _WIN32
            SCL::Option({"-L", "--linkdir"}, "Add a library searching path")
                .arg("dir")
                .multi()
                .short_match(SCL::Option::ShortMatchSingleChar),
#elif defined(__APPLE__)
            SCL::Option({"-d", "--debug"}, "Deploy debug frameworks"),
#endif
            SCL::Option({"-e", "--exclude"}, "Exclude a path pattern").arg("regex").multi(),
            SCL::Option({"-s", "--standard"}, "Ignore C/C++ runtime and system libraries"),
            SCL::Option({"-f", "--force"}, "Force overwrite existing files"),
        });
        command.addOption(verbose);
        command.setHandler(cmd_deploy);
        return command;
    }();

    SCL::Command rootCommand(SCL::appName(),
                             "Cross-platform utility commands for C/C++ build systems.");
    rootCommand.addCommands({
        cpdirCommand,
        rmdirCommand,
        touchCommand,
        configureCommand,
        incsyncCommand,
        deployCommand,
    });
    rootCommand.addVersionOption(TOOL_VERSION);
    rootCommand.addHelpOption(true, true);
    rootCommand.setHandler([](const SCL::ParseResult &result) -> int {
        result.showHelpText();
        return 0;
    });

    SCL::CommandCatalogue cc;
    cc.addCommands("Filesystem Commands", {"cpdir", "rmdir", "touch"});
    cc.addCommands("Developer Commands", {"configure", "incsync", "deploy"});
    rootCommand.setCatalogue(cc);

    SCL::Parser parser(rootCommand);
    parser.setPrologue(TOOL_DESC);
    parser.setDisplayOptions(SCL::Parser::AlignAllCatalogues);

    int ret;
    try {
#ifdef _WIN32
        std::ignore = argc;
        std::ignore = argv;
        ret = parser.invoke(SCL::commandLineArguments());
#else
        ret = parser.invoke(argc, argv);
#endif
    } catch (const std::exception &e) {
        std::string msg = e.what();

#ifdef _WIN32
        if (typeid(e) == typeid(std::filesystem::filesystem_error)) {
            auto err = static_cast<const std::filesystem::filesystem_error &>(e);
            // msg = "\"" + tstr2str(err.path1()) + "\": " + standardError();
            msg = Utils::local8bit_to_utf8(err.what());
        }
#endif

        SCL::u8debug(SCL::MT_Critical, true, "Error: %s\n", msg.data());
        ret = -1;
    }
    return ret;
}
