#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <cctype>
#include <algorithm>
#include <functional>
#include <filesystem>
#include <regex>
#include <codecvt>

#include <stdimpl.h>

#include "sha-256.h"

using namespace StdImpl;

#ifdef _WIN32
#  include <Windows.h>
#endif

static std::string tstr2str(const TString &str) {
#ifdef _WIN32
    int len =
        WideCharToMultiByte(CP_UTF8, 0, str.data(), (int) str.size(), nullptr, 0, nullptr, nullptr);
    auto buf = new char[len + 1];
    WideCharToMultiByte(CP_UTF8, 0, str.data(), (int) str.size(), buf, len, nullptr, nullptr);
    buf[len] = '\0';

    std::string res(buf);
    delete[] buf;
    return res;
#else
    return str;
#endif
}

static std::string toHeaderGuard(const std::string &filename) {
    std::string guard = filename;
    std::replace(guard.begin(), guard.end(), '.', '_');
    for (char &c : guard) {
        c = std::toupper(c);
    }
    return guard;
}

static std::string calculateHash(const std::string &data) {
    static const int sha_size = 32;

    uint8_t buf[sha_size];
    calc_sha_256(buf, data.data(), data.size());

    return toHexString({buf, buf + sha_size});
}

static int generateHeaderFile(const TString &filename, const std::vector<std::string> &defines) {
    std::stringstream definitions;
    for (const auto &def : defines) {
        size_t pos = def.find("=");
        if (pos != std::string::npos) {
            definitions << "#define " << def.substr(0, pos) << " " << def.substr(pos + 1) << "\n";
        } else {
            definitions << "#define " << def << "\n";
        }
    }
    auto hash = calculateHash(definitions.str());

    // Read file
    do {
        // Check if file exists and has the same hash
        std::ifstream inFile(filename);
        if (!inFile.is_open()) {
            break;
        }

        std::regex hashPattern(R"(^// SHA256: (\w+)$)");
        std::smatch match;
        std::string line;
        bool matched = false;

        int pp_cnt = 0;
        while (std::getline(inFile, line)) {
            if (line.empty())
                continue;

            if (line.starts_with('#')) {
                pp_cnt++; // Skip header guard
                if (pp_cnt > 2) {
                    break;
                }
                continue;
            }

            if (!line.starts_with("//"))
                break;

            if (std::regex_match(line, match, hashPattern)) {
                if (match[1] == hash) {
                    matched = true;
                }
                break;
            }
        }

        inFile.close();

        if (matched) {
            printf("Content matched. (%s)\n", hash.data());
            return 0; // Same hash found, no need to overwrite the file
        }

    } while (0);

    // Create file
    {
        std::ofstream outFile(filename);
        if (!outFile.is_open()) {
            tprintf(_TSTR("Failed to open file \"%s\"."), filename.data());
            return -1;
        }

        // Header guard
        std::string guard = toHeaderGuard(std::filesystem::path(filename).filename().string());
        outFile << "#ifndef " << guard << "\n";
        outFile << "#define " << guard << "\n\n";

        // Warning
        outFile << R"(// Caution: This file is generated by CMake automatically during configure.
// WARNING!!! DO NOT EDIT THIS FILE MANUALLY!!!
// ALL YOUR MODIFICATIONS HERE WILL GET LOST AFTER RE-CONFIGURING!!!

)";

        // Hash
        outFile << "// SHA256: " << hash << "\n\n";

        // Definitions
        outFile << definitions.str() << "\n";

        // Header guard end
        outFile << "#endif // " << guard << "\n";

        outFile.close();
    }

    return 0;
}

int main(int argc, char *argv[]) {
    (void) argc;
    (void) argv;

    // Parse arguments
    TStringList args = commandLineArguments();
    TStringList fileNames;
    std::vector<std::string> defines;
    bool showHelp = false;

    for (int i = 1; i < args.size(); ++i) {
        if (!tstrcmp(args[i], _TSTR("--help")) || !tstrcmp(args[i], _TSTR("-h"))) {
            showHelp = true;
            break;
        }
        if (!tstrcmp(args[i], _TSTR("--define")) || !tstrcmp(args[i], _TSTR("-D"))) {
            if (i + 1 < args.size()) {
                defines.emplace_back(tstr2str(args[i + 1]));
                i++;
            }
            continue;
        }

        if (args[i].starts_with(_TSTR("-D")) && args[i].size() > 2) {
            defines.emplace_back(tstr2str(args[i].substr(2)));
            continue;
        }

        fileNames.push_back(args[i]);
    }

    if (fileNames.size() != 1 || showHelp) {
        tprintf(_TSTR("Usage: %s [options] <output>\n"), appName().data());
        tprintf(_TSTR("Options:\n"));
        tprintf(_TSTR("    %-20s    Define a variable, format: \"key\" or \"key=value\"\n"),
                _TSTR("-D/--define <exp>"));
        tprintf(_TSTR("    %-20s    Show help message\n"), _TSTR("-h/--help"));
        return 0;
    }

    return generateHeaderFile(fileNames.at(0), defines);
}